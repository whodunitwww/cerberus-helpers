return function(a)local b=a.Services;local c=a.References;local d=a.Library;local e=a.Tabs;local f=a.Toggles;local g=a.Unloader;local h=a.AttachPanel;local i=a.fireAttack;local j=a.fireEquip;local k=a.hasWeaponEquipped;local l=a.fireProximityPrompt or fireproximityprompt;local m=b.HttpService or game:GetService("HttpService")local n="Cerberus/Reawakened"local o="Quest_Config_v4.json"local p=n.."/"..o;local q=92031872453631;local r="https://raw.githubusercontent.com/whodunitwww/cerberus-helpers/refs/heads/main/reawakened/questPriorityEditor.lua"local s={"S","A","B","C","D","E"}local t={"GateClearing","Subjugation","Investigation"}local u={GateClearing=true,Investigation=true}if not e or not e.Auto then return end;local v=e.Auto:AddLeftGroupbox("Auto Quest","scroll")v:AddLabel("Work in progress, will update on full release, currently first two gate clear, and all investigations are working",true)local w={State={Enabled=false,Running=false,NotifiedUnsupported=false,NotifiedAttachMissing=false,ActiveQuest=nil,BossSeen=false,NotifiedBossWait=false,AutoStartEnabled=false,AutoClearEnabled=false,AutoSkipEnabled=false,AutoSkipRan=false,AutoClaimEnabled=false,AutoClaimRan=false,NotifiedQuestActive=false,NotifiedQuestClientMissing=false,NotifiedQuestBoardMissing=false,NotifiedAutoStartBlocked=false,NotifiedAutoClearBlocked=false},attemptedPrompts={},PriorityConfig=nil,PriorityConfigRaw=nil,NextConfigCheck=0,ConfigCheckInterval=1,LastAutoStartAttempt=0,AutoStartCooldown=2,NotifiedNoQuest=false,LastAutoStartNotifyId=nil,LastAutoStartNotifyTime=0,QuestClient=nil,QuestBoard=nil,DataController=nil,RedEvent=nil,LastMarkerQuestName=nil,LastMarkerTeleportTime=0,MarkerTeleportCooldown=2,NotifiedMarkerMissing=false,LastClaimAttempt=0,ClaimCooldown=3,NotifiedClaimNone=false,AutoSkipThread=nil,AutoClaimThread=nil}local function x(y,z)local A=false;if d and d.Notify then A=pcall(d.Notify,d,y,z or 2)end;if not A then pcall(warn,y)end end;function w:StopAttach()if h and h.Stop then h.Stop()end end;function w:IsMainWorld()return game.PlaceId==q end;function w:ApplyPlaceRules()if self:IsMainWorld()then self.State.NotifiedAutoClearBlocked=true;self.State.NotifiedAutoStartBlocked=false else if self.State.AutoStartEnabled and not self.State.NotifiedAutoStartBlocked and d then self.State.NotifiedAutoStartBlocked=true end;self.State.NotifiedAutoClearBlocked=false end end;function w:GetDataController()if self.DataController then return self.DataController end;local B=b.Players.LocalPlayer;local C=B and(B:FindFirstChild("PlayerScripts")or B:WaitForChild("PlayerScripts",5))if not C then return nil end;local D=C:FindFirstChild("ClientControllers")or C:WaitForChild("ClientControllers",5)if not D then return nil end;local E=D:FindFirstChild("Data")or D:WaitForChild("Data",5)if not E then return nil end;local A,F=pcall(require,E)if not A then return nil end;self.DataController=F;return F end;function w:GetRedEvent()if self.RedEvent and self.RedEvent.Parent then return self.RedEvent end;local G=b.ReplicatedStorage:FindFirstChild("RedEvent")if G then self.RedEvent=G end;return G end;function w:RunAutoSkipCutscene()if not self.State.AutoSkipEnabled then return end;if self:IsMainWorld()then return end;if self.State.AutoSkipRan or self.AutoSkipThread then return end;self.AutoSkipThread=task.spawn(function()if not game:IsLoaded()then game.Loaded:Wait()end;local B=b.Players.LocalPlayer;if B and not B.Character then B.CharacterAdded:Wait()end;task.wait(0.5)if not self.State.AutoSkipEnabled or self:IsMainWorld()then self.AutoSkipThread=nil;return end;local G=self:GetRedEvent()or b.ReplicatedStorage:WaitForChild("RedEvent",10)if G then local H={{["\021"]={}},{}}G:FireServer(unpack(H))self.State.AutoSkipRan=true end;self.AutoSkipThread=nil end)end;function w:ClaimUnclaimedQuests()local I=os.clock()if I-(self.LastClaimAttempt or 0)<(self.ClaimCooldown or 3)then return end;self.LastClaimAttempt=I;local J=self:GetDataController()local G=self:GetRedEvent()if not J or not G or not J.GetSlotData then return end;local A,K=pcall(J.GetSlotData,J)if not A or not K or not K.Quests then return end;local L=0;for M,N in pairs(K.Quests)do if N and not N.Claimed then local H={{[")"]=M},{}}G:FireServer(unpack(H))L=L+1 end end;if L==0 then if not self.NotifiedClaimNone then self.NotifiedClaimNone=true end else self.NotifiedClaimNone=false;x(("Claimed %d quest%s."):format(L,L==1 and""or"s"),2)end end;function w:RunAutoClaimOnce()if not self.State.AutoClaimEnabled then return end;if not self:IsMainWorld()then return end;if self.State.AutoClaimRan or self.AutoClaimThread then return end;self.AutoClaimThread=task.spawn(function()if not game:IsLoaded()then game.Loaded:Wait()end;local B=b.Players.LocalPlayer;if B and not B.Character then B.CharacterAdded:Wait()end;task.wait(0.5)if not self.State.AutoClaimEnabled or not self:IsMainWorld()then self.AutoClaimThread=nil;return end;self:ClaimUnclaimedQuests()self.State.AutoClaimRan=true;self.AutoClaimThread=nil end)end;function w:GetActiveQuestMarker()local J=self:GetDataController()if not J or not J.GetSlotData then return nil end;local A,K=pcall(J.GetSlotData,J)if not A or not K or not K.Quests then return nil end;for M,N in pairs(K.Quests)do local O=N and N.ExtraArgs;local P=O and O.TrackPosition;if P then local Q;if typeof(P)=="Vector3"then Q=P elseif type(P)=="table"then if P[1]and P[2]and P[3]then Q=Vector3.new(P[1],P[2],P[3])elseif P.x and P.y and P.z then Q=Vector3.new(P.x,P.y,P.z)elseif P.X and P.Y and P.Z then Q=Vector3.new(P.X,P.Y,P.Z)end end;return M,Q end end;return nil end;function w:MaybeTeleportToMarker(M,Q)if not M or not Q then return end;local R=c.character or b.Players.LocalPlayer and b.Players.LocalPlayer.Character;local S=R and R:FindFirstChild("HumanoidRootPart")if S and(S.Position-Q).Magnitude<=10 then return end;local I=os.clock()if I-(self.LastMarkerTeleportTime or 0)<(self.MarkerTeleportCooldown or 2)and self.LastMarkerQuestName==M then return end;if R and R.Parent then R:PivotTo(CFrame.new(Q+Vector3.new(0,5,0)))self.LastMarkerTeleportTime=I;self.LastMarkerQuestName=M;if d then x("Auto Start: teleporting to quest marker.",2)end end end;function w:GetQuestTitle()local B=b.Players.LocalPlayer;local T=B and B:FindFirstChild("PlayerGui")or B and B:WaitForChild("PlayerGui",5)if not T then return nil end;local U=T:FindFirstChild("HUD")or T:WaitForChild("HUD",5)if not U then return nil end;local V=U:FindFirstChild("Quest")or U:WaitForChild("Quest",5)if not V then return nil end;local W=V:FindFirstChild("QuestTrack")or V:WaitForChild("QuestTrack",5)if not W then return nil end;local X=W:FindFirstChild("Title")or W:WaitForChild("Title",5)return X and X.Text or nil end;function w:IsQuestActive()local M=self:GetActiveQuestMarker()return M~=nil end;function w:BuildPriorityList(Y)local Z={}for _,a0 in ipairs(t)do if Y.EnabledTypes[a0]then for _,a1 in ipairs(s)do if Y.EnabledRanks[a1]then Z[#Z+1]=a0 .."|"..a1 end end end end;return Z end;function w:BuildDefaultPriorityConfig()local Y={EnabledRanks={},EnabledTypes={},PriorityList={}}for _,a1 in ipairs(s)do Y.EnabledRanks[a1]=true end;for _,a0 in ipairs(t)do Y.EnabledTypes[a0]=true end;Y.PriorityList=self:BuildPriorityList(Y)return Y end;function w:NormalizePriorityConfig(Y)if type(Y)~="table"then return self:BuildDefaultPriorityConfig()end;Y.EnabledRanks=Y.EnabledRanks or{}Y.EnabledTypes=Y.EnabledTypes or{}for _,a1 in ipairs(s)do if Y.EnabledRanks[a1]==nil then Y.EnabledRanks[a1]=true end end;for _,a0 in ipairs(t)do if Y.EnabledTypes[a0]==nil then Y.EnabledTypes[a0]=true end end;Y.PriorityList=Y.PriorityList or{}local a2={}local a3={}for _,a4 in ipairs(Y.PriorityList)do local a5,a6=a4:match("^(.*)|(.*)$")if a5 and a6 and Y.EnabledTypes[a5]and Y.EnabledRanks[a6]then a2[#a2+1]=a4;a3[a4]=true end end;for _,a0 in ipairs(t)do if Y.EnabledTypes[a0]then for _,a1 in ipairs(s)do if Y.EnabledRanks[a1]then local a4=a0 .."|"..a1;if not a3[a4]then a2[#a2+1]=a4 end end end end end;Y.PriorityList=a2;return Y end;function w:LoadPriorityConfig(a7)local a8;if isfile and isfile(p)then a8=readfile(p)elseif writefile then local a9=self:BuildDefaultPriorityConfig()a8=m:JSONEncode(a9)if makefolder and not isfolder(n)then pcall(makefolder,"Cerberus")pcall(makefolder,n)end;pcall(writefile,p,a8)end;if not a7 and a8 and a8==self.PriorityConfigRaw then return false end;local aa;if a8 then local A,F=pcall(m.JSONDecode,m,a8)if A and type(F)=="table"then aa=F end end;self.PriorityConfig=self:NormalizePriorityConfig(aa)self.PriorityConfigRaw=a8;self.LastAutoStartAttempt=0;self.NotifiedNoQuest=false;return true end;function w:MaybeRefreshPriorityConfig()local I=os.clock()if I<(self.NextConfigCheck or 0)then return end;self.NextConfigCheck=I+(self.ConfigCheckInterval or 1)self:LoadPriorityConfig(false)end;function w:EnsureQuestClient()if self.QuestClient then return self.QuestClient end;local ab=b.ReplicatedStorage:FindFirstChild("Modules")or b.ReplicatedStorage:WaitForChild("Modules",5)if not ab then return nil end;local ac=ab:FindFirstChild("Shared")or ab:WaitForChild("Shared",5)if not ac then return nil end;local ad=ac:FindFirstChild("Red")or ac:WaitForChild("Red",5)if not ad then return nil end;local A,ae=pcall(require,ad)if not A or not ae or not ae.Client then return nil end;self.QuestClient=ae.Client("Quests")return self.QuestClient end;function w:EnsureQuestBoard()if self.QuestBoard and self.QuestBoard.Parent then return self.QuestBoard end;local af=b.ReplicatedStorage:FindFirstChild("QuestBoard")or b.ReplicatedStorage:WaitForChild("QuestBoard",5)self.QuestBoard=af;return af end;function w:TryAutoStartQuest(X)if not self:IsMainWorld()then self:ApplyPlaceRules()return false end;local ag,ah=self:GetActiveQuestMarker()if ag then if ah then self:MaybeTeleportToMarker(ag,ah)self.State.NotifiedMarkerMissing=false elseif not self.State.NotifiedMarkerMissing and d then self.State.NotifiedMarkerMissing=true end;if not self.State.NotifiedQuestActive and d then self.State.NotifiedQuestActive=true end;return false end;if self:IsQuestActive(X)then if not self.State.NotifiedQuestActive and d then self.State.NotifiedQuestActive=true end;return false end;self.State.NotifiedQuestActive=false;local I=os.clock()if I-(self.LastAutoStartAttempt or 0)<(self.AutoStartCooldown or 2)then return false end;self.LastAutoStartAttempt=I;local ai=self:EnsureQuestClient()if not ai then if not self.State.NotifiedQuestClientMissing and d then self.State.NotifiedQuestClientMissing=true end;return false end;self.State.NotifiedQuestClientMissing=false;local aj=self:EnsureQuestBoard()if not aj then if not self.State.NotifiedQuestBoardMissing and d then self.State.NotifiedQuestBoardMissing=true end;return false end;self.State.NotifiedQuestBoardMissing=false;if not self.PriorityConfig then self:LoadPriorityConfig(true)end;local Z=self.PriorityConfig and self.PriorityConfig.PriorityList or{}if d then local ak=2;if I-(self.LastAutoStartNotifyTime or 0)>=ak then self.LastAutoStartNotifyTime=I end end;for _,al in ipairs(Z)do local a0=al:match("^(.*)|")if a0 and u[a0]then if d then local ak=2;if I-(self.LastAutoStartNotifyTime or 0)>=ak or self.LastAutoStartNotifyId~=al then self.LastAutoStartNotifyId=al;self.LastAutoStartNotifyTime=I end end;local am=aj:FindFirstChild(al)if am then ai:Fire("PickQuest",am)if d then x("Starting Quest: "..al,3)end;self.NotifiedNoQuest=false;return true end end end;if not self.NotifiedNoQuest and d then x("No prioritized quests available yet.",3)self.NotifiedNoQuest=true end;return false end;function w:UpdateRunState()local an=self.State.AutoStartEnabled and self:IsMainWorld()local ao=self.State.AutoClearEnabled and not self:IsMainWorld()self.State.Enabled=an or ao;self:ApplyPlaceRules()if self.State.AutoSkipEnabled then self:RunAutoSkipCutscene()end;if self.State.AutoClaimEnabled then self:RunAutoClaimOnce()end;if self.State.Enabled then if not self.State.Running then self:Run()end else self:StopAttach()end end;function w:CollectEntityNames()local ap={}local a3={}local aq=false;for _,ar in ipairs(b.Workspace:GetDescendants())do if ar:IsA("Model")and not b.Players:GetPlayerFromCharacter(ar)then local as=ar:FindFirstChildOfClass("Humanoid")if as and as.Health>0 then local at=ar.Name;if not a3[at]then a3[at]=true;ap[#ap+1]=at;if at=="Goblin[Archer]"then aq=true end end end end end;return ap,aq end;function w:IsGoblinTarget(au)if not au then return false end;local at=au.Name;return at=="Goblin"or at=="Goblin[Archer]"end;function w:IsGateBossTarget(au)if not au then return false end;return au.Name=="Goblin Boss"or au.Name=="Giant Arachnid"end;function w:GetGateBossTarget()local av=b.Workspace:FindFirstChild("Entities")local aw=av and(av:FindFirstChild("Giant Arachnid")or av:FindFirstChild("Goblin Boss"))if not aw then return nil end;self.State.BossSeen=true;if aw:IsA("Model")then local as=aw:FindFirstChildOfClass("Humanoid")if as and as.Health<=0 then return nil end end;return aw end;function w:GetGateBossAlive()return self:GetGateBossTarget()~=nil end;function w:GetTargetCFrame(ax,ay)local au=ay;if not au and ax then au=ax.Parent end;if not au then return nil end;if au:IsA("Attachment")then au=au.Parent end;if not au then return nil end;if au:IsA("BasePart")then return au.CFrame end;if au:IsA("Model")then return au:GetPivot()end;local az=au:FindFirstChildWhichIsA("BasePart")return az and az.CFrame or nil end;function w:GetAnyCluePrompt()local aA=b.Workspace:FindFirstChild("ClueSpawns")if not aA then return nil end;for _,aB in ipairs(aA:GetDescendants())do if aB:IsA("ProximityPrompt")and aB.Enabled~=false then return aB end end;return nil end;function w:GetNextCluePrompt()local aA=b.Workspace:FindFirstChild("ClueSpawns")if not aA then return nil,nil end;for _,aB in ipairs(aA:GetDescendants())do if aB:IsA("ProximityPrompt")and aB.Enabled~=false then if not self.attemptedPrompts[aB]then return aB,nil end end end;return nil,nil end;function w:ResetForQuest(X)self.State.ActiveQuest=X;self.State.NotifiedUnsupported=false;self.State.NotifiedAttachMissing=false;self.State.BossSeen=false;self.State.NotifiedBossWait=false;self.attemptedPrompts={}self.NotifiedNoQuest=false;self.State.NotifiedQuestActive=false;self.State.NotifiedQuestClientMissing=false;self.State.NotifiedQuestBoardMissing=false;self.State.NotifiedAutoStartBlocked=false;self.State.NotifiedAutoClearBlocked=false;self.State.NotifiedMarkerMissing=false;self.NotifiedClaimNone=false;self:StopAttach()end;function w:Stop()self.State.Enabled=false;self:StopAttach()if f and f.AutoQuest then f.AutoQuest:SetValue(false)end end;function w:HandleInvestigation()if not l then if d then x("fireproximityprompt not available.",3)end;self:Stop()return false end;local ax,ay=self:GetNextCluePrompt()if not ax then if self:GetAnyCluePrompt()then task.wait(0.5)self.attemptedPrompts={}return true end;task.wait(1)if self:GetAnyCluePrompt()then self.attemptedPrompts={}return true end;if d then x("No clues left. Quest complete.",3)end;self:Stop()return false end;local aC=self:GetTargetCFrame(ax,ay)if aC then local R=c.character or b.Players.LocalPlayer and b.Players.LocalPlayer.Character;if R and R.Parent then R:PivotTo(aC+Vector3.new(0,5,0))end;task.wait(0.15)self.attemptedPrompts[ax]=true;pcall(l,ax)local aD=0;while self.State.Enabled and aD<0.5 do task.wait(0.2)aD=aD+0.2 end else self.attemptedPrompts[ax]=true;task.wait(0.5)end;return true end;function w:HandleGateClearing()if not h or not h.State then if not self.State.NotifiedAttachMissing then self.State.NotifiedAttachMissing=true end;task.wait(1)return true end;local B=b.Players.LocalPlayer;local R=B and B.Character;local aE=R and R:FindFirstChildOfClass("Humanoid")local S=R and R:FindFirstChild("HumanoidRootPart")if not(R and S and aE and aE.Health>0)then self:StopAttach()task.wait(0.5)return true end;if k and j and not k()then j()task.wait(0.1)end;h.State.targetType="Entities"if h.SetMovement then h.SetMovement("Teleport")end;h.SetMode("Aligned")h.SetHorizDist(0)local aF,aq=self:CollectEntityNames()local aG=self:GetGateBossTarget()local aH=aG and aG.Name or nil;if#aF==0 then local aI=self:GetGateBossAlive()if aI or not self.State.BossSeen then if not self.State.NotifiedBossWait then if d then x("Waiting for final boss.",3)end;self.State.NotifiedBossWait=true end;task.wait(1)return true end;if d then x("No entities left. Quest complete.",3)end;self:Stop()return false end;local aJ;if aH then aJ={aH}elseif aq then aJ={"Goblin[Archer]"}else aJ=aF end;h.SetSelectedNames(aJ)local aK=h.State.currentTarget;local aL=h.State.stage;local aM=not h.State.running;if not aK or aL=="Idle"then aM=true else local aN=false;for _,at in ipairs(aJ)do if aK.Name==at then aN=true;break end end;if not aN then aM=true end end;if aM then h.Start()end;if h.EnableDodge then h.EnableDodge(true)elseif h.State and h.State.dodgeMode~=true then h.State.dodgeMode=true end;if aH=="Goblin Boss"then h.SetYOffset(10)elseif aH=="Giant Arachnid"then h.SetYOffset(4)elseif h.State.currentTarget and h.State.currentTarget.Name=="Steel-Fanged Lycan"then h.SetYOffset(6)elseif self:IsGoblinTarget(h.State.currentTarget)then h.SetYOffset(5)else h.SetYOffset(8.5)end;if h.State.stage=="Attach"and h.State.currentTarget then i("M1")task.wait(0.05)else task.wait(0.1)end;return true end;function w:HandleIdle(X)if not self.State.AutoClearEnabled then task.wait(0.5)return end;if not self:IsQuestActive(X)then task.wait(0.5)return end;if not self.State.NotifiedUnsupported then self.State.NotifiedUnsupported=true end;task.wait(1)end;function w:Run()if self.State.Running then return end;self.State.Running=true;self.State.NotifiedUnsupported=false;self.State.NotifiedAttachMissing=false;self.attemptedPrompts={}task.spawn(function()while self.State.Enabled do self:ApplyPlaceRules()self:MaybeRefreshPriorityConfig()local X=self:GetQuestTitle()if X~=self.State.ActiveQuest then self:ResetForQuest(X)end;if self.State.AutoStartEnabled and self:IsMainWorld()and self:TryAutoStartQuest(X)then task.wait(0.5)X=self:GetQuestTitle()end;if self.State.AutoClearEnabled and not self:IsMainWorld()then if X and X:find("Investigation",1,true)then self.State.NotifiedUnsupported=false;if not self:HandleInvestigation()then break end elseif X and X:find("Gate Clearing",1,true)then self.State.NotifiedUnsupported=false;if not self:HandleGateClearing()then break end else self:HandleIdle(X)end else task.wait(0.5)end end;self.State.Running=false end)end;v:AddToggle("AutoQuest_AutoStart",{Text="Auto Start Quest",Default=false,Callback=function(aO)w.State.AutoStartEnabled=aO;w:UpdateRunState()end})v:AddToggle("AutoQuest_AutoClear",{Text="Auto Clear Quest",Default=false,Callback=function(aO)w.State.AutoClearEnabled=aO;if not aO then w:StopAttach()end;w:UpdateRunState()end})v:AddToggle("AutoQuest_AutoSkipCutscene",{Text="Auto Skip Cutscene",Default=false,Callback=function(aO)w.State.AutoSkipEnabled=aO;if aO then w:RunAutoSkipCutscene()end end})v:AddToggle("AutoQuest_AutoClaim",{Text="Auto Claim Quests",Default=false,Callback=function(aO)w.State.AutoClaimEnabled=aO;if aO then w:RunAutoClaimOnce()end end})v:AddButton("Quest Priority Editor",function()loadstring(game:HttpGet(r))()w:LoadPriorityConfig(true)end)if g and g.Register then g:Register(function()w.State.Enabled=false;w:StopAttach()end)end;w:LoadPriorityConfig(true)w:UpdateRunState()return w end
