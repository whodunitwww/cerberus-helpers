return function(a)local b=a.Services;local c=a.References;local d=a.Tabs;local e=a.Unloader;local f=a.Library;local g=a.PathfindingService or b.PathfindingService;if not d or not d.Auto or not g then return{}end;local h=b.ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("DropBrainrotEvent")local i=b.ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("DamageBlockEvent")local j=d.Auto:AddLeftGroupbox("AutoFarm","bot")local k=j:AddLabel("Idle",true)local l={Enabled=false,RunId=0,TravelSpeed=36,StopDistance=10,ActiveHumanoid=nil,OriginalWalkSpeed=nil,BlocksData=nil,UnreachableTargets={},IncomeThreshold=5000,BrainrotRange=100,AuraRange=25}local function m(n)if k.SetText then k:SetText(n)else k.Text=n end end;local function o(p,q)if f and f.Notify then f:Notify(p,q or 3)end end;local function r()if l.BlocksData then return l.BlocksData end;local s,t=pcall(function()return require(b.ReplicatedStorage:WaitForChild("BlocksModule",5))end)l.BlocksData=s and type(t)=="table"and t or{}return l.BlocksData end;local u=5;local v=8;local function w(x)if not x then return false end;local y=l.UnreachableTargets[x]if not y then return false end;if tick()-y>=u then l.UnreachableTargets[x]=nil;return false end;return true end;local function z(x)if x then l.UnreachableTargets[x]=tick()end end;local function A(B)if not B then return nil end;if B:IsA("BasePart")then return B.Position end;if B:IsA("Model")then local C,D=pcall(function()return B:GetPivot()end)if C and D then return D.Position end;local E=B:FindFirstChildWhichIsA("BasePart")if E then return E.Position end end;return nil end;local function F(G)if not G then return false end;return G.PlatformStand or G:GetState()==Enum.HumanoidStateType.Physics end;local function H(n)if type(n)~="string"then return nil end;local I=n:gsub("[^%d%.]","")if I==""then return nil end;return tonumber(I)end;local function J(K)if not K then return nil end;local L=K:FindFirstChild("Mesh")local M=L and L:FindFirstChild("InfoGui")local N=M and M:FindFirstChild("Frame")local O=N and N:FindFirstChild("CharCash")local n=O and O.Text;return H(n)end;local function P(K)local L=K and K:FindFirstChild("Mesh")if not L then return nil end;local Q=L:FindFirstChild("PickupPrompt")if Q and Q:IsA("ProximityPrompt")then return Q end;return nil end;local function R(K)local S=A(K)if not S then return nil end;return S end;local function T(K)if not K then return nil end;local U=K:GetAttribute("CountdownEnd")if type(U)~="number"then U=tonumber(U)end;if type(U)~="number"then return nil end;local V=U-os.time()return V end;local function W(X)local Y=b.Workspace:FindFirstChild("LuckyBlocks")if not Y then return nil end;local Z=r()local _=math.huge;local a0={}for a1,x in ipairs(Y:GetChildren())do if not w(x)then local S=A(x)if S then local a2=math.huge;local a3="Unknown"local a4=Z[x.Name]if type(a4)=="table"then a2=tonumber(a4.Rarity)or a2;a3=a4.RarityType or a3 end;if a2<_ then _=a2;a0={}end;if a2==_ then local a5=X and(S-X).Magnitude or 0;a0[#a0+1]={instance=x,position=S,rarity=a2,rarityLabel=a3,distance=a5}end end end end;if#a0==0 then return nil end;local a6=a0[1]for a7=2,#a0 do if a0[a7].distance<a6.distance then a6=a0[a7]end end;return a6 end;local function a8()if not c.player then return end;local a9=c.character or c.player.Character;local aa=c.player:FindFirstChild("Backpack")local G=c.humanoid;if not aa or not G or not a9 then return end;for a1,ab in ipairs(a9:GetChildren())do if ab:IsA("Tool")and ab.Name~="Six Seven"then ab.Parent=aa end end;local ac=a9:FindFirstChild("Six Seven")if ac then return end;local ad=aa:FindFirstChild("Six Seven")if ad and ad:IsA("Tool")then G:EquipTool(ad)end end;local function ae(X)local Y=b.Workspace:FindFirstChild("Brainrots")if not Y then return nil end;local af=nil;for a1,K in ipairs(Y:GetChildren())do if K and K.Parent and not w(K)then local S=R(K)if S then local a5=X and(S-X).Magnitude or math.huge;local ag=false;if K:GetAttribute("Carried")==true and a5>10 then ag=true end;if not ag and a5<=l.BrainrotRange then local ah=J(K)if ah and ah>=l.IncomeThreshold then local V=T(K)if not V or V>=v then if not af or ah>af.income or ah==af.income and a5<af.distance then af={instance=K,position=S,income=ah,distance=a5}end end end end end end end;return af end;local function ai(G)if not G then return end;if l.ActiveHumanoid and l.ActiveHumanoid~=G then if l.OriginalWalkSpeed then l.ActiveHumanoid.WalkSpeed=l.OriginalWalkSpeed end;l.ActiveHumanoid=nil;l.OriginalWalkSpeed=nil end;if not l.ActiveHumanoid then l.ActiveHumanoid=G;l.OriginalWalkSpeed=G.WalkSpeed end;G.WalkSpeed=l.TravelSpeed end;local function aj()if l.ActiveHumanoid and l.OriginalWalkSpeed then l.ActiveHumanoid.WalkSpeed=l.OriginalWalkSpeed end;l.ActiveHumanoid=nil;l.OriginalWalkSpeed=nil end;local function ak(X,al,am)if not X or not al then return nil end;local an=am or l.StopDistance;local ao=al-X;local a5=ao.Magnitude;if a5<=an then return X end;if a5==0 then return X end;local ap=ao.Unit;return al-ap*an end;local function aq(al,G,X,ar,as,at)if not G or not X or not al then return false end;local au=at or l.StopDistance;local av=g:CreatePath({AgentHeight=5,AgentRadius=2,AgentCanJump=true})local s,aw=pcall(function()av:ComputeAsync(X,al)end)if not s or av.Status~=Enum.PathStatus.Success then if av.Status==Enum.PathStatus.NoPath then return false,"NoPath"end;return false,"ComputeFailed"end;local ax=av:GetWaypoints()local ay=c.humanoidRootPart and c.humanoidRootPart.Position or X;local az=tick()local aA=0.2;local aB=1.5;local aC=3.5;for a1,aD in ipairs(ax)do if l.RunId~=ar or not l.Enabled then return false end;if as and(not as.Parent or not as:GetAttribute("Carried"))then return false,"LostBrainrot"end;if F(G)then return false,"Ragdolled"end;if aD.Action==Enum.PathWaypointAction.Jump then G.Jump=true end;G:MoveTo(aD.Position)local aE=false;local aF=false;while not aF do if l.RunId~=ar or not l.Enabled then return false end;if as and(not as.Parent or not as:GetAttribute("Carried"))then return false,"LostBrainrot"end;if F(G)then return false,"Ragdolled"end;local aG=c.humanoidRootPart.Position;local aH=(Vector3.new(aG.X,0,aG.Z)-Vector3.new(aD.Position.X,0,aD.Position.Z)).Magnitude;if aH<au then if(al-aG).Magnitude<au then aF=true;aE=true;break end end;if aH<4 then aF=true;aE=true;break end;local aI=(aG-ay).Magnitude;if aI<aA then if tick()-az>aC then return false,"StuckHard"elseif tick()-az>aB then G.Jump=true end else az=tick()ay=aG end;task.wait(0.1)end;if not aE then return false,"MoveToFailed"end end;return true,nil end;local function aJ(al,G,X,ar,as,at)if c.humanoidRootPart and c.humanoidRootPart.Position.Z<-120 then local aG=c.humanoidRootPart.Position;c.humanoidRootPart.CFrame=CFrame.new(aG.X,aG.Y,-119)task.wait(0.05)X=c.humanoidRootPart.Position end;local au=at or l.StopDistance;local aK=120;local aL=X;local aM=0;local aN=15;while true do if as and(not as.Parent or not as:GetAttribute("Carried"))then return false,"LostBrainrot"end;if F(G)then return false,"Ragdolled"end;local ao=al-aL;local a5=ao.Magnitude;if a5<=0.5 then return true,nil end;local aO=al;if a5>aK then aO=aL+ao.Unit*aK end;local aP,aQ=aq(aO,G,aL,ar,as,au)if not aP then return false,aQ end;aL=c.humanoidRootPart and c.humanoidRootPart.Position or aO;if(al-aL).Magnitude<=au then return true,nil end;aM=aM+1;if aM>=aN then return false,"SegmentLimit"end end end;local function aR(aS,G,ar,aT)if not aS or not G then return false end;if aS.Position.Z<=-130 then return true end;if aT and not aT:GetAttribute("Carried")then warn("[AutoFarm] Not carrying brainrot, skipping return trip.")return false end;local aU=0;local aV=3;local aW=false;while aU<aV do local aX=Vector3.new(aS.Position.X,aS.Position.Y,-115)local aY,aQ=aJ(aX,G,aS.Position,ar,aT)if aQ=="Ragdolled"then return false end;if not aY and aQ=="LostBrainrot"then warn("[AutoFarm] Lost brainrot while returning! Aborting return.")return false end;if aY then aW=true;break else warn("[AutoFarm] Return path failed ("..tostring(aQ).."), retrying... "..tostring(aU+1))aU=aU+1;task.wait(0.5)end end;if aT and not aT:GetAttribute("Carried")then warn("[AutoFarm] Lost brainrot before teleport! Aborting.")return false end;local aZ=Vector3.new(aS.Position.X,aS.Position.Y,-130)if aS then aS.CFrame=CFrame.new(aZ)task.wait(0.1)end;return true end;local function a_(b0,G,aS,ar)if not b0 or not b0.instance or not G or not aS then return false end;o(("Found Brainrot: %s ($%s/s)"):format(b0.instance.Name,tostring(b0.income)),3)if not b0.instance:GetAttribute("Carried")then h:FireServer()task.wait(0.1)end;local b1=ak(aS.Position,b0.position,5)if not b1 then return false end;local aP,aQ=aJ(b1,G,aS.Position,ar,nil,5)if not aP then if aQ=="Ragdolled"then return false end;if aQ=="NoPath"or aQ=="StuckHard"then z(b0.instance)end;o("Failed to reach brainrot: "..(aQ or"?"),2)return false end;m(("Collecting brainrot %s ($%s/s)"):format(b0.instance.Name,tostring(b0.income)))local b2=0;local b3=3;local b4=false;while b2<b3 and not b4 do local Q=P(b0.instance)if Q and fireproximityprompt then pcall(fireproximityprompt,Q,0)end;task.wait(0.4)local b5=0;while b5<10 do if not b0.instance or not b0.instance.Parent then break end;if b0.instance:GetAttribute("Carried")==true then b4=true;break end;task.wait(0.1)b5=b5+1 end;if not b4 then b2=b2+1;if b2<b3 then o("Pickup failed, retrying...",1)task.wait(0.5)end end end;if b4 then o("Picked up! Returning to base...",3)ai(G)m("Crossing line threshold")aR(aS,G,ar,b0.instance)return true else o("Failed to pick up brainrot after retries.",3)return false end end;local function b6()l.RunId=l.RunId+1;local ar=l.RunId;task.spawn(function()while l.Enabled and l.RunId==ar do pcall(function()local b7=b.Workspace:FindFirstChild("LuckyBlocks")local aS=c.humanoidRootPart;if b7 and aS then local X=aS.Position;for a1,x in ipairs(b7:GetChildren())do if l.Enabled and l.RunId==ar then local b8=A(x)if b8 and(b8-X).Magnitude<=l.AuraRange then i:FireServer(x)end else break end end end end)task.wait(0.1)end end)task.spawn(function()while l.Enabled and l.RunId==ar do local G=c.humanoid;local aS=c.humanoidRootPart;if F(G)then m("Ragdolled - Waiting...")task.wait(0.1)elseif not G or not aS or G.Health<=0 then m("Waiting for character...")task.wait(0.5)else ai(G)a8()local b9=ae(aS.Position)if b9 then m(("Heading to brainrot %s ($%s/s)"):format(b9.instance.Name,tostring(b9.income)))a_(b9,G,aS,ar)task.wait(0.1)else local b0=W(aS.Position)if not b0 or not b0.instance or not b0.instance.Parent then m("No lucky blocks available")task.wait(1)else local a5=(b0.position-aS.Position).Magnitude;local ba=("%s (%s rarity)"):format(b0.instance.Name,b0.rarityLabel)if a5<=l.StopDistance then m(("Near %s"):format(ba))if b0.rarity and b0.rarity<50 then local bb=tick()while tick()-bb<1.5 do if not l.Enabled then break end;local bc=ae(aS.Position)if bc then m("Interrupting wait for Brainrot!")a_(bc,G,aS,ar)break end;task.wait(0.1)end else task.wait(0.2)end else m(("Heading to %s"):format(ba))local bd=A(b0.instance)local b1=ak(aS.Position,bd or b0.position)if not b1 then m("Target vanished")task.wait(0.3)else local aP,aQ=aJ(b1,G,aS.Position,ar)if aP then m(("Arrived at %s"):format(ba))task.wait(0.1)else if aQ=="NoPath"or aQ=="StuckHard"then z(b0.instance)end;m(("Could not reach %s: %s"):format(ba,aQ or"unknown"))warn("[AutoFarm] Failed to reach target:",aQ or"unknown")task.wait(0.2)end end end end end end end;aj()end)end;local function be()l.Enabled=false;l.RunId=l.RunId+1;aj()end;local function bf(bg)if l.Enabled==bg then return end;if bg then l.Enabled=true;m("Starting AutoFarm...")b6()else m("Stopping AutoFarm...")be()m("AutoFarm disabled")end end;j:AddToggle("AutoFarmEnabled",{Text="Enable AutoFarm",Default=false,Callback=bf})j:AddSlider("AutoFarmIncome",{Text="Brainrot Income Threshold ($/s)",Min=100,Max=50000,Rounding=0,Default=l.IncomeThreshold,Callback=function(bg)l.IncomeThreshold=bg end})j:AddSlider("AutoFarmRange",{Text="Brainrot Range (studs)",Min=20,Max=400,Rounding=0,Default=l.BrainrotRange,Callback=function(bg)l.BrainrotRange=bg end})e:Register(function()be()m("AutoFarm disabled")end)return{SetEnabled=bf}end
