return function(a)local b=a.Services;local c=a.Tabs;local d=a.References;local e=a.Library;local f=a.Options;local g=a.Toggles;local h=a.Unloader;local i=a.SenseSrc;local j=a.ESPConfig or{}local k=j.Debug==true;local l={}local function m(n,o)if l[n]then return end;l[n]=true;if e and e.Notify then e:Notify(o,6)else warn(o)end end;if j.Enabled~=true then return end;local p={}local q={}local function r(s)if s then p[#p+1]=s end;return s end;local t={universal={textSize={Default=13,Min=10,Max=28},tracerOrigin={Default="Bottom",Values={"Bottom","Middle","Top"}},limitRange={Default=false},maxRange={Default=150,Min=50,Max=2000}}}local function u(v,w)local x={}if type(w)=="table"then for y,z in pairs(w)do x[y]=z end end;if type(v)=="table"then for y,z in pairs(v)do x[y]=z end end;if x.Default==nil then x.Default=x.default end;if x.Min==nil then x.Min=x.min end;if x.Max==nil then x.Max=x.max end;if x.Values==nil then x.Values=x.values end;return x end;local function A(B,w)local C=f and f[B]if C and C.Value~=nil then return C.Value end;return w end;local function D(B,w)local E=g and g[B]if E and E.Value~=nil then return E.Value end;return w end;local function F(G)if G==nil or G==false then return false end;if type(G)=="table"and G.Enabled==false then return false end;return true end;local function H(G,n,w)if type(G)=="table"and G[n]~=nil then return G[n]end;return w end;local I=j.Universal or j.universal;if not I and j.CONFIG and j.CONFIG.universal then I=j.CONFIG.universal end;I=I or{}local J=u(I.TextSize or I.textSize,t.universal.textSize)local K=u(I.TracerOrigin or I.tracerOrigin,t.universal.tracerOrigin)local L=u(I.LimitRange or I.limitRange,t.universal.limitRange)local M=u(I.MaxRange or I.maxRange,t.universal.maxRange)local N=I.Enabled~=false;local O=j.Groups or j.groups;if not O and j.CONFIG and j.CONFIG.groups then O=j.CONFIG.groups end;O=O or{}local P=j.Objects or j.objects;if not P and j.CONFIG and j.CONFIG.objects then P=j.CONFIG.objects end;P=P or{}local Q=P.Types or P.types or j.ObjectsTypes or{}local R=P.Enabled~=false;local S={SENSE=nil,SenseInstCache={},SenseInstConn={},Objects={Types=R and Q or{},Caches={},Connections={},LastRescan=0}}local function T()if not S.SENSE or S.SENSE.__CerberusPatched then return end;S.SENSE.__CerberusPatched=true;local U=S.SENSE.getCharacter;local V=S.SENSE.getHealth;local function W(X)if typeof(X)~="Instance"then return nil end;local Y;if X:IsA("Player")then Y=X.Character elseif X:IsA("Model")then Y=X elseif U then local Z,_=pcall(U,X)if Z then Y=_ end end;if not Y then return nil end;local a0=Y:FindFirstChildOfClass("Humanoid")if not a0 then return nil end;if a0.Health<=0 or a0:GetState()==Enum.HumanoidStateType.Dead then return nil end;return Y end;function S.SENSE.getCharacter(X)return W(X)end;function S.SENSE.getHealth(X)local Y=W(X)local a0=Y and Y:FindFirstChildOfClass("Humanoid")if a0 then return a0.Health,a0.MaxHealth end;return 0,0 end end;local function a1()if not S.SENSE then return end;local a2=A("ESP_TracerOrigin",K.Default)S.SENSE.sharedSettings.textSize=A("ESP_TextSize",J.Default)S.SENSE.sharedSettings.limitDistance=D("ESP_LimitRange",L.Default)S.SENSE.sharedSettings.maxDistance=A("ESP_MaxRange",M.Default)S.SENSE.teamSettings.enemy.tracerOrigin=a2;S.SENSE.teamSettings.friendly.tracerOrigin=a2;if S.SENSE.instanceSettings then S.SENSE.instanceSettings.tracerOrigin=a2 end end;local function a3()if not S.SENSE then if type(Drawing)~="table"or type(Drawing.new)~="function"then m("drawing","ESP: Drawing API not available. ESP cannot render.")return false end;if type(i)~="string"then m("sense_src","ESP: Sense source missing or invalid.")return false end;local Z,a4=pcall(loadstring,i)if not Z or type(a4)~="function"then m("sense_load","ESP: Failed to load Sense module."..(k and" "..tostring(a4)or""))return false end;local a5,a6=pcall(a4)if not a5 or type(a6)~="table"then m("sense_ctor","ESP: Sense module failed to initialize."..(k and" "..tostring(a6)or""))return false end;S.SENSE=a6 end;if not S.SENSE then return false end;if not S.SENSE._hasLoaded and S.SENSE.Load then pcall(S.SENSE.Load)end;T()a1()return true end;local a7=false;local function a8()if not g then return false end;for a9,aa in ipairs(O)do if aa and aa.key then local E=g[aa.key.."_Enable"]if E and E.Value then return true end end end;return false end;local function ab()for a9,ac in pairs(q)do pcall(ac)end end;local function ad()if a7 then return end;a7=true;task.spawn(function()local ae=0;while ae<30 do ae=ae+1;if a3()then ab()break end;if not a8()then break end;task.wait(0.5)end;a7=false end)end;local function af(B,ag)local a2=g[B]or f[B]if a2 and a2.OnChanged then a2:OnChanged(ag)end end;if N then local ah=c.ESP:AddLeftGroupbox("Universal","settings")if J.Enabled~=false then ah:AddSlider("ESP_TextSize",{Text="Text Size",Default=J.Default,Min=J.Min,Max=J.Max,Rounding=0})end;if K.Enabled~=false then ah:AddDropdown("ESP_TracerOrigin",{Text="Tracer Origin",Values=K.Values,Default=K.Default})end;if L.Enabled~=false then ah:AddToggle("ESP_LimitRange",{Text="Limit Range",Default=L.Default})end;if M.Enabled~=false then ah:AddSlider("ESP_MaxRange",{Text="Range (studs)",Default=M.Default,Min=M.Min,Max=M.Max,Rounding=0})end end;af("ESP_TextSize",function()if a3()then a1()end end)af("ESP_TracerOrigin",function()if a3()then a1()end end)af("ESP_LimitRange",function()if a3()then a1()end end)af("ESP_MaxRange",function()if a3()then a1()end end)local function ai(aa,aj)local ak=aj=="left"and c.ESP.AddLeftGroupbox or c.ESP.AddRightGroupbox;local al=ak(c.ESP,aa.title,aa.icon or"users")al:AddToggle(aa.key.."_Enable",{Text="Enable "..aa.title,Default=false})al:AddDropdown(aa.key.."_Side",{Text="Apply To",Values={"Enemy","Friendly","Both"},Default=aa.sideDefault or"Enemy"})local am=aa.features and aa.features.box;if F(am)then al:AddToggle(aa.key.."_Box",{Text="Boxes",Default=H(am,"Default",true)}):AddColorPicker(aa.key.."_BoxColor",{Default=H(am,"color",Color3.new(1,1,1))})al:AddToggle(aa.key.."_BoxOutline",{Text="Box Outline",Default=H(am,"outline",true)})al:AddToggle(aa.key.."_BoxFill",{Text="Box Fill",Default=H(am,"fill",false)})al:AddSlider(aa.key.."_BoxFillAlpha",{Text="Fill Alpha",Default=H(am,"fillAlpha",35),Min=0,Max=100})end;local an=aa.features and aa.features.name;if F(an)then al:AddToggle(aa.key.."_Name",{Text="Names",Default=H(an,"Default",true)}):AddColorPicker(aa.key.."_NameColor",{Default=H(an,"color",Color3.new(1,1,1))})end;local ao=aa.features and aa.features.distance;if F(ao)then al:AddToggle(aa.key.."_Distance",{Text="Distance",Default=H(ao,"Default",false)}):AddColorPicker(aa.key.."_DistColor",{Default=H(ao,"color",Color3.new(1,1,1))})end;local ap=aa.features and aa.features.healthBar;if F(ap)then al:AddToggle(aa.key.."_HealthBar",{Text="Health Bar",Default=H(ap,"Default",true)})end;local aq=aa.features and aa.features.weapon;if F(aq)then al:AddToggle(aa.key.."_Weapon",{Text="Weapon",Default=H(aq,"Default",false)})end;local K=aa.features and aa.features.tracer;if F(K)then al:AddToggle(aa.key.."_Tracer",{Text="Tracer",Default=H(K,"Default",false)}):AddColorPicker(aa.key.."_TracerColor",{Default=H(K,"color",Color3.new(1,1,1))})end;local ar=aa.features and aa.features.chams;if F(ar)then al:AddToggle(aa.key.."_Chams",{Text="Chams",Default=H(ar,"Default",true)})end;local function as()if not a3()then ad()return end;local at=A(aa.key.."_Side",aa.sideDefault or"Enemy")local au=at=="Both"and{"enemy","friendly"}or{at:lower()}for a9,av in ipairs(au)do local E=S.SENSE.teamSettings[av]if E then E.enabled=D(aa.key.."_Enable",false)if F(am)then E.box=D(aa.key.."_Box",H(am,"Default",true))E.boxOutline=D(aa.key.."_BoxOutline",H(am,"outline",true))E.boxFill=D(aa.key.."_BoxFill",H(am,"fill",false))local aw=A(aa.key.."_BoxFillAlpha",H(am,"fillAlpha",35))local ax=A(aa.key.."_BoxColor",H(am,"color",Color3.new(1,1,1)))E.boxColor={ax,1}E.boxFillColor={ax,aw/100}else E.box=false;E.boxOutline=false;E.boxFill=false end;if F(an)then E.name=D(aa.key.."_Name",H(an,"Default",true))E.nameColor={A(aa.key.."_NameColor",H(an,"color",Color3.new(1,1,1))),1}else E.name=false end;if F(ao)then E.distance=D(aa.key.."_Distance",H(ao,"Default",false))E.distanceColor={A(aa.key.."_DistColor",H(ao,"color",Color3.new(1,1,1))),1}else E.distance=false end;if F(ap)then E.healthBar=D(aa.key.."_HealthBar",H(ap,"Default",true))else E.healthBar=false end;if F(aq)then E.weapon=D(aa.key.."_Weapon",H(aq,"Default",false))else E.weapon=false end;if F(K)then E.tracer=D(aa.key.."_Tracer",H(K,"Default",false))E.tracerColor={A(aa.key.."_TracerColor",H(K,"color",Color3.new(1,1,1))),1}else E.tracer=false end;if F(ar)then E.chams=D(aa.key.."_Chams",H(ar,"Default",true))else E.chams=false end end end;a1()end;q[aa.key]=as;af(aa.key.."_Enable",as)for a9,B in ipairs({aa.key.."_Side",aa.key.."_Box",aa.key.."_BoxFill",aa.key.."_BoxFillAlpha",aa.key.."_BoxOutline",aa.key.."_Name",aa.key.."_Distance",aa.key.."_HealthBar",aa.key.."_Weapon",aa.key.."_Tracer",aa.key.."_Chams",aa.key.."_BoxColor",aa.key.."_NameColor",aa.key.."_DistColor",aa.key.."_TracerColor"})do af(B,as)end end;local function ay(aa)if not S.SENSE then return end;local az=S.SenseInstCache[aa.key]if not az then return end;for aA in pairs(az)do pcall(function()if S.SENSE.RemoveInstance then S.SENSE.RemoveInstance(aA)elseif S.SENSE.RemoveInstances then S.SENSE.RemoveInstances({aA})end end)end;S.SenseInstCache[aa.key]={}end;local function aB(aa)if not a3()then ad()return end;local aC=S.SENSE.instanceSettings;if not aC then return end;local n=aa.key;local aD=aa.features or{}aC.enabled=D(n.."_Enable",false)local am=aD.box;if F(am)then aC.box=D(n.."_Box",H(am,"Default",true))aC.boxColor={A(n.."_BoxColor",H(am,"color",Color3.new(1,1,1))),1}aC.boxOutlineColor={Color3.new(),1}aC.boxFillColor={A(n.."_BoxColor",H(am,"color",Color3.new(1,1,1))),A(n.."_BoxFillAlpha",H(am,"fillAlpha",25))/100}aC.boxOutline=D(n.."_BoxOutline",H(am,"outline",true))aC.boxFill=D(n.."_BoxFill",H(am,"fill",false))else aC.box=false;aC.boxOutline=false;aC.boxFill=false end;local an=aD.name;if F(an)then aC.name=D(n.."_Name",H(an,"Default",true))aC.nameColor={A(n.."_NameColor",H(an,"color",Color3.new(1,1,1))),1}else aC.name=false end;local ao=aD.distance;if F(ao)then aC.distance=D(n.."_Distance",H(ao,"Default",true))aC.distanceColor={A(n.."_DistColor",H(ao,"color",Color3.new(1,1,1))),1}else aC.distance=false end;local aE=aD.tracer;if F(aE)then aC.tracer=D(n.."_Tracer",H(aE,"Default",true))aC.tracerColor={A(n.."_TracerColor",H(aE,"color",Color3.new(1,1,1))),1}aC.tracerOutline=true else aC.tracer=false end;local ap=aD.healthBar;if F(ap)then aC.healthBar=D(n.."_HealthBar",H(ap,"Default",true))else aC.healthBar=false end;local ar=aD.chams;if F(ar)then aC.chams=D(n.."_Chams",H(ar,"Default",true))else aC.chams=false end;a1()end;local function aF(aa)if not a3()then ad()return end;S.SenseInstCache[aa.key]=S.SenseInstCache[aa.key]or{}local az=S.SenseInstCache[aa.key]local aG={}local Z,aH=pcall(aa.selector,b.Workspace)if Z and type(aH)=="table"then aG=aH end;local aI={}if#aG>0 then for a9,aA in ipairs(aG)do if aA and aA.Parent then aI[aA]=true;if not az[aA]then az[aA]=true;pcall(function()if S.SENSE.AddInstances then S.SENSE.AddInstances({aA})elseif S.SENSE.AddInstance then S.SENSE.AddInstance(aA,S.SENSE.instanceSettings or{})end end)end end end end;for aA in pairs(az)do if not aA.Parent or not aI[aA]then az[aA]=nil;pcall(function()if S.SENSE.RemoveInstance then S.SENSE.RemoveInstance(aA)elseif S.SENSE.RemoveInstances then S.SENSE.RemoveInstances({aA})end end)end end end;local function aJ(aa)if not a3()then ad()return end;aB(aa)aF(aa)if S.SenseInstConn[aa.key]then S.SenseInstConn[aa.key]:Disconnect()end;S.SenseInstConn[aa.key]=r(b.RunService.Heartbeat:Connect(function()if not D(aa.key.."_Enable",false)then return end;if tick()%0.5<0.02 then aB(aa)aF(aa)end end))end;local function aK(aa)if S.SenseInstConn[aa.key]then S.SenseInstConn[aa.key]:Disconnect()S.SenseInstConn[aa.key]=nil end;ay(aa)if S.SENSE and S.SENSE.instanceSettings then S.SENSE.instanceSettings.enabled=false end end;local function aL(aa,aj)local ak=aj=="left"and c.ESP.AddLeftGroupbox or c.ESP.AddRightGroupbox;local al=ak(c.ESP,aa.title,aa.icon or"user-cog")al:AddToggle(aa.key.."_Enable",{Text="Enable "..aa.title,Default=false})local am=aa.features and aa.features.box;if F(am)then al:AddToggle(aa.key.."_Box",{Text="Boxes",Default=H(am,"Default",true)}):AddColorPicker(aa.key.."_BoxColor",{Default=H(am,"color",Color3.new(1,1,1))})al:AddToggle(aa.key.."_BoxOutline",{Text="Box Outline",Default=H(am,"outline",true)})al:AddToggle(aa.key.."_BoxFill",{Text="Box Fill",Default=H(am,"fill",false)})al:AddSlider(aa.key.."_BoxFillAlpha",{Text="Fill Alpha",Default=H(am,"fillAlpha",25),Min=0,Max=100})end;local an=aa.features and aa.features.name;if F(an)then al:AddToggle(aa.key.."_Name",{Text="Names",Default=H(an,"Default",true)}):AddColorPicker(aa.key.."_NameColor",{Default=H(an,"color",Color3.new(1,1,1))})end;local ao=aa.features and aa.features.distance;if F(ao)then al:AddToggle(aa.key.."_Distance",{Text="Distance",Default=H(ao,"Default",true)}):AddColorPicker(aa.key.."_DistColor",{Default=H(ao,"color",Color3.new(1,1,1))})end;local aE=aa.features and aa.features.tracer;if F(aE)then al:AddToggle(aa.key.."_Tracer",{Text="Tracer",Default=H(aE,"Default",true)}):AddColorPicker(aa.key.."_TracerColor",{Default=H(aE,"color",Color3.new(1,1,1))})end;local ap=aa.features and aa.features.healthBar;if F(ap)then al:AddToggle(aa.key.."_HealthBar",{Text="Health Bar",Default=H(ap,"Default",true)})end;local ar=aa.features and aa.features.chams;if F(ar)then al:AddToggle(aa.key.."_Chams",{Text="Chams",Default=H(ar,"Default",true)})end;local function aM()if D(aa.key.."_Enable",false)then aJ(aa)else aK(aa)end end;af(aa.key.."_Enable",aM)for a9,B in ipairs({aa.key.."_Box",aa.key.."_BoxOutline",aa.key.."_BoxFill",aa.key.."_BoxFillAlpha",aa.key.."_Name",aa.key.."_Distance",aa.key.."_Tracer",aa.key.."_HealthBar",aa.key.."_Chams",aa.key.."_BoxColor",aa.key.."_NameColor",aa.key.."_DistColor",aa.key.."_TracerColor","ESP_TextSize","ESP_TracerOrigin","ESP_LimitRange","ESP_MaxRange"})do af(B,aM)end;q[aa.key]=aM end;local aN;if#S.Objects.Types>0 then aN=c.ESP:AddRightGroupbox("Other ESP","eye")for a9,v in ipairs(S.Objects.Types)do aN:AddToggle(v.key,{Text=v.label,Default=false}):AddColorPicker(v.key.."_Color",{Default=Color3.new(1,1,1)})end end;local function aO(aP)local az=S.Objects.Caches[aP]if not az then return end;for aA,aQ in pairs(az)do if aQ and aQ.Remove then pcall(function()aQ:Remove()end)elseif aQ and typeof(aQ)=="table"and aQ.Destroy then pcall(function()aQ:Destroy()end)end;az[aA]=nil end;S.Objects.Caches[aP]={}end;local function aR(v)local aP=v.key;S.Objects.Caches[aP]=S.Objects.Caches[aP]or{}local az=S.Objects.Caches[aP]local aS=D(aP,false)if not aS then aO(aP)return end;local aT=v.getFolder()local aI={}if aT then local aU=aT:GetDescendants()table.insert(aU,aT)for a9,aA in ipairs(aU)do if aA and aA.Parent and aA:IsA(v.className)then aI[aA]=true;if not az[aA]then local aV=Drawing.new("Text")aV.Center=true;aV.Outline=true;aV.Size=A("ESP_TextSize",J.Default)aV.Text=v.getName(aA)aV.Visible=false;az[aA]=aV end end end end;for aA,aQ in pairs(az)do if not aA.Parent or not aI[aA]then if aQ and aQ.Remove then pcall(function()aQ:Remove()end)end;az[aA]=nil end end end;local function aW()if#S.Objects.Types==0 then return end;local aX=b.Workspace.CurrentCamera;if not aX then return end;local aY=tick()local aZ=D("ESP_LimitRange",L.Default)local a_=A("ESP_MaxRange",M.Default)if aY-(S.Objects.LastRescan or 0)>0.5 then S.Objects.LastRescan=aY;for a9,v in ipairs(S.Objects.Types)do aR(v)end end;local Y=d.character;local b0=Y and Y:FindFirstChild("HumanoidRootPart")for a9,v in ipairs(S.Objects.Types)do local aP=v.key;local aS=D(aP,false)local az=S.Objects.Caches[aP]if az and aS then local b1=A(aP.."_Color",Color3.new(1,1,1))local b2=A("ESP_TextSize",J.Default)for aA,aQ in pairs(az)do if aA and aA.Parent and aQ then local b3=v.getPosition(aA)if b3 then local b4=true;if aZ and b0 then b4=(b0.Position-b3).Magnitude<=a_ end;local b5,b6=aX:WorldToViewportPoint(b3)if b6 and b4 then aQ.Position=Vector2.new(b5.X,b5.Y)aQ.Color=b1;aQ.Size=b2;aQ.Text=v.getName(aA)aQ.Visible=true else aQ.Visible=false end else aQ.Visible=false end elseif aQ then aQ.Visible=false end end elseif az then for a9,aQ in pairs(az)do if aQ then aQ.Visible=false end end end end end;if#S.Objects.Types>0 then S.Objects.Connections.Update=r(b.RunService.RenderStepped:Connect(aW))end;for a9,v in ipairs(S.Objects.Types)do af(v.key,function()S.Objects.LastRescan=0;aR(v)end)af(v.key.."_Color",function()end)end;local b7=false;for b8,aa in ipairs(O)do if aa and aa.key and aa.title and aa.type and aa.Enabled~=false then local aj=aa.uiSide;if aj~="left"and aj~="right"then aj=b8%2==0 and"left"or"right"end;if aa.type=="players"then b7=true;ai(aa,aj)elseif aa.type=="sense_instances"then b7=true;aL(aa,aj)end end end;if b7 then ad()end;if h then h:Register(function()for a9,aa in ipairs(O)do if aa and aa.key and aa.Enabled~=false and aa.type=="sense_instances"then aK(aa)end end;if S.SENSE then if S.SENSE.teamSettings then for a9,E in pairs(S.SENSE.teamSettings)do if type(E)=="table"and E.enabled~=nil then E.enabled=false end end end;if S.SENSE.instanceSettings then S.SENSE.instanceSettings.enabled=false end;if S.SENSE.Unload then pcall(S.SENSE.Unload)end end;if S.Objects.Connections.Update then S.Objects.Connections.Update:Disconnect()S.Objects.Connections.Update=nil end;for a9,v in ipairs(S.Objects.Types)do aO(v.key)end;for b8=#p,1,-1 do local b9=p[b8]p[b8]=nil;pcall(function()if b9 and b9.Disconnect then b9:Disconnect()end end)end end)end;return{ensureSense=a3}end
